
## What is programming?

John Chambers defines programming as "a language and environment to 
turn ideas into new tools." [Programming with Data, p. 2]

> "This book is about *programming with data*, meaning that we want to
extend the tools available in some way, to *program* the system to 
implement some ideas we have." [Programming with Data, p. 2]

> "Sometimes, it seems that the software we use just sort of sprang
into existance, like grass growing on the lawn. But it didn't. It was
created by someone who wrote out---in code---a long, painstaking set of
instructions telling the computer precisely what to do, step-by-step, 
to get a job done. There's a sort of priestly class mystery cultivated
around the word *algorithm*, but all they consist of are instructions:
Do this, then do this, then do this. News Feed [in Facebook] is now an
extraordinarily *complicated* algorithm involving some trained machine
learning; but it's ultimately still just a list of rules." [Coders, p. 10]

> "The first recorded use of 'Hello, World!' was in 1972, when a young 
computer scientist named Brain Kernighan was writing the manual explaining
how to program in the coding language called B. He wanted to show the simplest
thing you could get B to do, which was to print out a message. As he told 
me, he'd seen a cartoon of a chick coming out of an egg, saying 'Hello, World!',
and liked its funny, quirky ring. So he wrote a simple snippet of B code 
that displayed that little message. Coders quickly glommed on to Kernighan's
witty idea, and ever since then, virtually every guide to a programming
language---and there are over 250---begins with that one incantation. 
'Hello, World!' neatly distilled the existential jolt of coding: the 
creation of a life-form that jolts into being." [Coders, p. 14]

> "More than introversion or logic, though, coding selects for people who
can handle endless frustration. Because while computers may do 
whatever you tell them, you need to give them inhumanly precise 
instructions. ... Programming languages are languages, a method of 
speaking to machines; but to speak to a computer is to speak to the 
most literal-minded entity on the planet, a ruthlessly prissy 
grammarian. When we speak to humans, they put a lot of work into 
helping interpret what we say. Computers don't. They will take every
single last one of your smallest errors and grind them in your face, 
until you fix them." [Coders, p. 17] 

> "'When you learn to program a computer, you almost never get it
right the first time,' noted the pioneering computer scientist and
educator Seymour Papert, back in 1980. He regarded the experience as
the pivot around which all coder psychology turns. You write some code, 
you try to run it; it fails; so most of your job is figuring out what the
hell you just did wrong. Those who can handle that daily vexation thrive.
Those who can't, flee." [Coders, pp. 17--18] 

> "Code, in other words, is really good at making things *scale*. Computers
may require utterly precise instructions, but if you get the instructions
right, the machine will tirelessly do what you command over and over and
over again, for users around the world. ... Solve a problem once, and you've
solved it for everyone." [Coders, p. 20]

> "Since they have, at their beck and call, machines that can repeat
instructions with robotic perfection, coders take a dim view of doing 
things repetitively themselves. They have a dislike of inefficiency
that is almost aesthetic---they recoil from it as if from a disgusting
smell. Any opportunity they have to automate a process, to do something
more efficiently, they will." [Coders, p. 20]

> "[Wesley Clark] wanted to make the world's first 'personal computer', 
one that could fit in a single office or laboratory room. No more 
waiting in line; one scientist would have it all to himself (or, more
rarely, herself). Clark wanted specifically to target biologists, since
he knew they often needed to crunch data in the middle of an experiment.
At that time, if they were using a huge IBM machine, they'd need to stop
and wait their turn. If they had a personal computer in their own lab? They
could do calculations on the fly, rejiggering their experiment as they 
went. It would even have its own keyboard and screen, so you could program
more quickly: no clumsy punch cards or printouts. It would be a symbiosis of
human and machine intelligence. Or, as Wilkes put it, you'd have 
'conversational access' to the LINC: You type some code, you see the result
quickly. Clark knew he and his team could design the hardware. But he needed
Wilkes to help create the computers' operating system that would let the user
control the hardware in real time. And it would have to be simple enough that
biologists could pick it up with a day or two of training." [Coders, p. 32]

> "When they had a rough first prototype [of the LINC] working, Clark tested
it on a real-life problem of biological research. He and his colleague 
Charles Molnar dragged a LINC out to the lab of neurologist Arnold Starr, who
had been trying and failing to record the neuroelectric signals cats produce
in their brains when they heard a sound. Starr had put an electrode implant
into a cat's cortex, but he couldn't distinguish the precise neuroelectirc
signal he was looking for. In a few hours, Molnar wrote a program for the 
LINC that would play a clicking noise out of a speaker, record precisely 
when the electrode fired, and map on the LINC's screen the average response
of the cat to noises. It worked: As data scrolled across the screen, the
scientists 'danced a jig right around the equipment'." [Coders, p. 33]

> "'The distance between looking like a genius and looking like an 
idiot in programming? It's *one character wide.*'" [Rob Spectre, on 
missing a colon, Coders, p. 64]

> "Coding is, in a profound way, less about making thinks than about 
fixing them. The pioneering computer scientist Seymour Papert had a 
koan: *No program works right the first time.*" [Coders, p. 66]

> "Programmers are obsessed with efficiency. ... Removing the friction 
from a system is an aesthetic joy; [programmers'] eyes blaze when they
talk about making something run faster, or how they eliminated some 
bothersome human effort from a process." [Coders, p. 122]

> "Computers, in many ways, inspire dreams of efficiency greater than
any tool that came before. That's because they're remarkably good at
automating repetitive tasks. Write a script once, set it running, and
the computer will tirelessly execute it until it dies or the power
runs out. What's more, computers are strong in precisely the ways that
humans are weak. Give us a repetitive task, and our mind tends to 
wander, so we gradually perform it more and more irregularly. Ask us
to do something at a precise time or interval, and we space out and 
forget to do it. ... In contrast, computers are clock driven and superb
at doing the same thing at the same time, day in and day out."
[Coders, p. 124]

> "Larry Wall, the famous coder and linguist who created the Perl 
programming language, deeply intuited this coderly aversion to 
repetition. In his book on Perl, he and coauthors wrote that one of the
key virtues of a programmer is 'laziness'. It's not that you're too lazy
for coding. It's that you're too lazy to do routine things, so it 
inspires you to automate them." [Coders p. 126]

> "'Refactoring' is, in a way, like editing. When you're writing a letter
or a speech or an article, often the first draft is a bit baggy and fuzzy.
You're getting the ideas out onto the page, but they're not crisply stated.
So you repeat yourself; you beat around the bush; your thinking is fuzzy.
But that's okay, because your goal isn't to be perfect, it's to get those 
first words onto the page, so you can reshape and hone them later. 
Editing sharpens and hones those flabby ideas and language. It 
pares down your pointless and windy riffs, so that the prose tightens 
and tempers. That's why editing a piece of writing---lingering over it, 
molding it---can make it shorter, not longer. ... So it is with programming.
Generally speaking, the tighter the code, the better. That's partly because
the fewer lines of code that exist, the less likely one is to introduce
a bug. A huge pile of 'spaghetti code' is a bog in which bugs can hide. 
When the code is shorter and tighter, it's easier to see precisely what
it's supposed to be doing and not doing. It's a forest of spare birch 
trees; you can see right through it." [Coders, p. 136]

> "[The ENIAC Girls] invented groundbreaking ideas in coding. Synder 
realized that if you wanted to debug a program that wasn't running
correctly, it's help to have a 'break point', a moment when you could
stop a program midway through its run. When she pitched the idea to male
engineers running ENIAC, they agreed to implement it; and to this day, coders
use break points as a key part of debugging." [Coders, pp. 190--191]

> "Computers are much pickier and less flexible about spelling than
humans; thus hackers need to be very precise when talking about characters, 
and have developed a considerable amount of verbal shorthand for them.
Every character [in ASCII] has one or more names---some formal, some concise,
some silly. Common jargon names for ASCII characters are collected here. ...
!: Common: bang; pling; excl; shriek; exclamation mark [official ASCII 
name]; ... #: Common: number sign; pound; pound sign; hash; sharp; crunch; 
hex. ... [asterisk]: Common: star; splat; asterisk [official ASCII name]; 
/: Common: slash; stroke; slant [official ASCII name]; forward slash; 
\: Common: backslash; escape (from C/Unix); reverse slash; slosh; 
backslant; backwhack. [underline]: Common: underline [official ASCII name]; 
underscore; underbar; under; |: Common: bar; or; or-bar; v-bar; pipe; 
vertical bar; ~: Common: tilde [official ASCII name]; squiggle; tiddle; not."
[New Hackers Dictionary, pp. 44--46] 

> "**metasyntactic variable** *n.* A name used in example and understood
to stand for whatever thing is under discussion, or any random number
of things under discussion. The word foo is the canonical example.
To avoid confusion, hackers never (well, hardly ever) use 'foo' or other
words like it as permanent names for anything. In filenames, a common 
convention is that any filename beginning with a metasyntactic-variable
name is a scratch file that may be deleted at any time. To some extent, the
list of one's preferred metasyntactic variables is a cultural signature. 
They occur both in series (used for related groups of variables or objects)
and as singletons. Here are a few common signatures: foo, bar, baz, quux, 
quuux, quuuux, ...: MIT/Stanford usage, now found everywhere ... ; bazola, 
ztesch: Stanford (from the mid-70s on); ... snork: Brown University, early
1970s; ... blarg, wibble: New Zealand; toto, titi, tata, tutu: France; 
pippo, pluto, paperino: Italy. Pippo and Paperino are the Italian names for
Goofy and Donald Duck; app, noot, mies: The Netherlands. These are the first
words a child used to learn to spell on a Dutch spelling board."
[New Hacker's Dictionary, pp.301--302] 

> "**batch** *adj.* 1. Non-interactive. ... A *batch file* is a series of 
instructions written to be handed to an interactive program running in 
batch model. 2. Performance of dreary tasks all at one sitting. 'I finally
sat down in batch mode and wrote out checks for all those bills...'"
[New Hacker's Dictionary, p. 58] 

> "**cd tilde** *vi.* To go home. From the Unix C-shell and Korn-shell
command 'cd ~', which takes one to one's $HOME (cd with no argument
happens to do the same thing)." [New Hackers Dictionary, p. 106]

> "**comment out** *vt.* To surround a section of code with comment 
delimiters or to prefix every line in the section with a comment marker;
this prevents it from being compiled or interpreted. Often done when the
code is redundant or obsolete, but is left in the source to make the 
intent of the active code cleaner; also when the code in that section is
broken and you want to bypass it in order to debug some other part of the 
code." [New Hackers Dictionary, p. 118]

> "**deprecated** *adj.* Said of a program or feature that is considered
obsolescent and in the process of being phased out, usually in favor 
of a specified replacement." [New Hackers Dictionary, p. 150]

> "**dot file** *n.* A file that is not visible by default to 
normal directory-browsing tools (on Unix, files named with a leading dot
are, by convention, not normally presented in directory listings. Many 
programs define one or more dot files in which startup or configuration
information may be optionally recorded; a user can customize the 
program's behavior by creating the appropriate file in the current or
home directory." [New Hackers Dictionary, p. 158] 

> "**recursive acronym** *n.* A hackish (and especially MIT) tradition
is to choose acronyms / abbreviations that refer humorously to 
themselves or to other acronyms / abbreviations. The classic examples
were two MIT editors called EINE ('EINE is not EMACS') and ZWEI
('ZWEI Was EINE Initially'). ... GNU stands for 'GNU's Not Unix'."
[New Hackers Dictionary, pp. 381--382]

> "**Hook** *n.* A software or hardware feature included in order to
simplify later additions or changes by a user." [New Hackers
Dictionary, p. 248] 

> "**path** *n.* ... 2. [Unix] A file name, fully specified relative 
to the root directory (as opposed to relative to the current 
directory; the later is sometimes called a *relative path*). This is
also called a *pathname*." [New Hackers Dictionary, p. 350]

> "**program** *n.* 1. A magic spell cast over a computer allowing
it to turn one's input into error messages. 2. An exercise in 
experimental epistemology. 3. A form of art, ostensibly 
intended for the instruction of computers, which is nevertheless
almost inevitably a failure if other programmers can't understand
it." [New Hackers Dictionary, p. 365]

> "The 80-column width of most character terminals is a legacy of the
IBM punched card." [New Hackers Dictionary, p. 368]

> "**shell** *n.* 1. [techspeak] The command interpreter used to pass
commands to an operating system; so called because it is the part
of the operating system that interfaces with the outside world. ...
Historical note: Apparently, the original Multics shell (sense 1) was
so-called because it was a shell (sense 3 [a skeleton program, created
by hand or by another program]; it ran user programs not by starting up
separate processes, but by dynamically linking the programs into its 
own code, calling them subroutines, and then dynamically de-linking 
them on return." [New Hackers Dictionary, pp. 404--405]

> "**spaghetti code** *n.* Code with a complex and tangled structure, 
especially one using many GOTOs, exceptions, or other 'unstructured'
branching constructs." [New Hackers Dictionary, p. 420]

> "**text** *n.* ... 2. Textual material in the mainstream sense; data
in ordinary ASCII or EBCDIC representation (see 'flat-ASCII'). 'Those
are text files, you can review them using the editor.'" [New Hackers
Dictionary, pp. 442--443]

> "**tool** *n.* ... 2. [Unix] An application program with a simple, 
'transparent' (typically text-stream) interface designed specifically
to be used in programmed combination with other tools (see filter, 
plumbing)." [New Hackers Dictionary, p. 449] 

## Functions

> "S is a *functional* language. S expressions contain function calls. ...
An S function call returns an S object, the value of the call. Usually that's 
all it does: function calls are evaluated to get the value." 
[Programming with Data, p. 7]

> "Calls to functions can have any number of arguments, and the arguments
can be any S expression." [Programming with Data, p. 8]

> "Each function is defined with some set of *formal arguments*. The 
arguments supplied in the call are matched to those in the definition." 
[Programming with Data, p. 9]

> "Not all the arguments in the definition need to be supplied in the call. 
The function can detect missing arguments. There may be a default 
expression included in the definition, or the function may do something
else, or it may be that for this particular call the argument wasn't needed
anyway." [Programming with Data, p. 9]

> "S will complete argument names, so long as you give enough of the 
name to make it unique." [Programming with Data, p. 9]  

> "S has the usual operators for arithmetic, comparisons, and logical 
operations (plus some other operators special to S). ... Operators look
different from other functions because they appear in expressions in 
infix (scientific) notation. When we come to program with such operators, 
though, we will treat them just like ordinary functions, which is what they
are. We put the operator '<' between two arguments instead of in front of
its arguments, but this is just because the interface we are using expects
to parse such expressions. Most users prefer to see arithmetic expressions 
written this way, but in fact the S expression `"<"(amount, 0)` evaluates
exactly the same as `amount < 0`." [Programming with Data, p. 10] 

Check out `?Arithmetic` and `?Logic`.

> "S has a few other operators not found in most languages. The operator
`:` creates a sequence in steps of +/- 1 from its left operand to its right
operand. ... Operator `%%` computes modulus. Some special matrix operators
do computations in numerical linear algebra, such as matrix multiplication.
Additional operators in S extract pieces of objects. Square brackets can 
be used to extract the portion of the object before the `[` that corresponds
to the expression between the square brackets. ... Square brackets can be
extended to apply to matrices, multiway arrays, and other similar objects. ...
Other operators extract single elements, components of lists, or the slots of
an object [e.g., `[[`, `$`, and `@`]." [Programming with Data, p. 11]

> "*Assignment*, written `=` in our examples, is another important S operator. 
S uses assignment in a very general way, both to assign an object corresponding
to a name and also to modify an object in an open-ended variety of ways."
[Programming with Data, p. 11]

> "Assignment operators are used to modify existing objects, when the expression
on the left of the assignment is a function call instead of a name. We call
these expressions *replacements*." [Programming with Data, p. 11]

> "Programming in S begins for real when you start writing S functions."
[Programming with Data, p. 19]

> "Often, you find yourself writing the same, or similar, expressions
over and over. It makes sens to package these as a function." 
[Programming with Data, p. 19]

> "You can create a function by just typing in an expression that defines
and assigns a `function` object. The idea is simple: take an expression
you would use to compute something interesting, precede the expression 
by `function` followed by the parenthesized names of the objects involved,
and that expression defines a function. ... Like any assignment expression, 
this tells S to evaluate the expression on the right of the `=` and associate
it with the name on the left. The difference in this case is that the expression
on the right, when parsed, defines a *function object*. The parser converts
the reserved word `function`, followed by a parenthesized list of arguments, 
followed by an S expression into a function object. The expression is called
the *body* of the function object." [Programming with Data, p. 19]

> "There is *no* difference between a function created by a user's program and
one supplied with S." [Programming with Data, p. 20]

> "Often, we need the function body to contain several expressions, including
assignments. The technique is to enclose these expressions in braces and 
separate them by semicolons or new lines. As in many languages, the expressions
in the braced list are evaluated one after another. In S, the key point is that
the value of the whole braced list is the value of the last expression."
[Programming with Data, p. 20]

> "The other key difference between tasks and function definitions is that
ordinary assignments in the body of the function ... now become *local* 
assignments in the evaluation of a call to [the function]. The assignments
and any storage they require go away when the call is completed."
[Programming with Data, p. 20]

> "Methods in S define how a particular function should behave, based on the
class of the arguments to the function." [Programming with Data, p. 32]

> "Once we can create objects from the class conveniently, we want to look
at them. A method for the function `show` will be called when S automatically
displays the result of a computation. The function takes only one argument, 
`object`, the object to be displayed. The display can be either printed
(the usual choice) or plotted. Two other functions, `print` and `plot`, can
also have methods defined for these two cases. These functions have a more 
general form, but the method for a new class is usually called with just
one argument. The function `summary` is expected to produce a short
description, ideally to fit on a single page regardless of the size of the
object." [Programming with Data, p. 40]

> "A function object contains two types of information. The *formal arguments*
tell S how to interpret calls to the function, and the *body* is the 
expression whose value is returned from the call. ... When the S evaluator
has matched the actual arguments to the formal arguments, it evaluates
the body and returns the resulting object as the value of the call." 
[Programming with Data, p. 79]

> "Because users can call S functions with named and unnamed arguments, 
both the position and the name of an argument in the function 
definition is relevant. We say 'formal' arguments when we want to 
distinguish the arguments in the function definition from the 
'actual' arguments in a call to the function. Besides the names of
the formal arguments, the definition can include assignment 
expressions to create *default* values for arguments that are
needed in evaluating the body, but that are not supplied in the call."
[Programming with Data, p. 79]

> "When S is evaluating the body of the function and, for the first time, 
needs the value of the argument `x`, it will look for a matched 
expression; if there is one, that expression is evaluated and assigned
locally as `x`... Notice that an argument is evaluated when S *needs* the
value; this technique is known as *lazy* evaluation and is essential to 
the generality in treating arguments."  [Programming with Data, p. 80]

> "S expressions consist largely of function calls. Functions are called
by following the definition of the function with a parenthesized list
of arguments. The definition is usually entered by typing the name under
which the function is stored in a database." [Programming with Data, p. 128]

> "A few nonstandard infix operators are supplied as well. The most 
important ... is the `?` operator, which invokes online help. It is 
most commonly used as a unary operator, followed by a name or a 
character string. ... You need ... quotes [e.g., `?"+"`] if the
topic you are asking about is not syntactically a name, since the 
S parser will get an error without the quotes." [Programming with 
Data, p. 129]

> "All the extraction operators [e.g., `[`] can also appear on the left
side of an assignment, in which case they are interpreted to mean replacing
the corresponding subset, element, or slot."[Programming with Data, p. 130] 

> "The `return` control expression causes the current function call to 
return, with the argument to the expression evaluated as the value of the
function call. ... A `return` is not needed if the functio body is a 
braced sequence of expressions and the last expression is the value you 
want to return from the function. In functional languages, `return` 
expressions are rather deprecated, in that they usually make it harder
to see the behavior of the function."  [Programming with Data, p. 136]

> "S assignment expressions consist of an assignment operator, with an
expression on the left and another on the right. The expression on the 
right is the *value* of the assignment; the expression on the left is
either a name or a function call." [Programming with Data, p. 137]

> "When an assignment occurs *inside* an argument to a function, the 
operator `<-` must be used to distinguish the intended argument from 
a named argument ... Otherwise, the operators [`=` and `<-`] behave
identically. The arrow form requires a little more typicing and is less
familiar to programmers from other languages, but it expresses the 
asymmetric relation of the left and right side in an assignment, where 
`=` does not." [Programming with Data, p. 137]

> "Assignment expressions also appear whenever you name an argument in 
a function call, though they are called *named arguments* in this case
and are interpreted somewhat differently. The call to any function 
associates each of the actual arguments with the name of one of the 
formal arguments of the function. S lets you omit names or supply just
enough of the name match, but the end result is the same as if all the
arguments had been named." [Programming with Data, pp. 138--139]

> "Assignments can appear in the argument list in the function *definition*
as well, to specify the default expressions for arguments." 
[Programming with Data, p. 139]

> "Modeling in S takes the data and a description of the model, applies
a numerical fitting algorithm, and returns an object representing the 
fitted model. Methods exist to print, summarize, and plot these models. 
... Models are described in two parts: the general kind of model being
used (linear regression, non-linear regression, tree-based models, etc.)
is determined by the choice of fitting function (`lm`, `nsl`, `tree`, etc.). 
The specific formula is a stylized S expression; specifically, a call to the 
special operator `~`, which can be read as 'is fitted to' in formulas. The
left-side operand defines the variable (the data) to be approximated, the
right-side operand the combination of variables to be used for fitting.
... The formula expression itself (the call to `~`) does no fitting, but 
just returns essentially the expression itself, as a 'formula' object. 
It's up to the fitting function to interpret the formula as a fitting 
task. The `lm` function uses the formula to define a linear model that
it then proceeds to fit by least-squares. The left side, or *response*, 
is an expression defining a numeric vector or matrix. The right side
defines one or more predictor variables; by convention, different
predictors are combined by `+`. The variables appearing in the model 
look like ordinary S objects, and they can be just that. More commonly, 
though, they are defined in the context of some particular dataset. In this
case, the user's call to the fitted function supplies a `data` argument.
The fitting function attaches this object temporarily in order to compute
the information needed to do the actual fit. Therefore, components of the
object can appear as variables in the formula." [Programming with Data, 
p. 167] 

> "Most coding is about breaking a big, hard task down into small pieces.
You don't write one big honking program at one go; you write little chunks
of code, small subroutines---functions, modules---that, when chained together,
accomplish the big task. If you were cooking breakfast, you could think of 
each action you do as a function: Cracking the eggs is function `(crackeggs())`,
buttering the toast is another `(buttertoast())`. Chain them all together in
a logical flow, and that's your main program. Generally when you're coding,
you're focusing on creating one function at a time, and after you've written 
it you're supposed to test it to make sure it works. If you spent days 
writing a long program without testing its various components, it would
almost certainly fail when you tried to run it, and it might be very hard
to figure out which part (or parts) of the program was the problem. So you 
go piece by piece, testing as you go. You get a little 'win' every time a 
function passes its test." [Coders, p. 84] 

> "Named arguments [in a function] look like assignments, and in a sense
they are, but of a special kind. The name in the assignment must match
one of the formal arguments of the function definition, and the assignment
does not take place until the corresponding argument is evaluated."
[Programming with Data, p. 179]

> "Computations sometimes need to examine or put together arbitrarily 
many objects: to form a list; to write out all the objects, to set 
any number of options or parameters. S provides a special argument name, 
'...', for this purpose. When this name appears as a formal argument in 
a function definition, any number of actual arguments in a corresponding
call will be matched to '...' in the evaulation frame. Then, if '...' 
appears as an argument in a function call in the body, the matching
arguments will be passed down, exactly as they appear, including any 
names." [Programming with Data, p. 183]

## Objects

> "When the S evaluator encounters the name of an object, it takes that
as a shorthand request to get the object from the database. And if nothing
else is done with the results, S will show the object to the user, by 
printing or plotting it. So about the simplest useful S expression is 
just the name of an object." [Programming with Data, p. 7]

> "S will evaluate the right side of the assignment expression and save the
result in a database, called in S the *working data*, under the name on the
left side. Then the object [by that name] is available for future tasks, 
whenever we are working with this database." [Programming with Data, p. 11]

> "Data in S comes in the form of *objects*. *Everything is an object:*
this is a fundamental concept in S. In many ways all objects are treated 
equally. Alls objects have a *class*, allowing computations on the objects
to be customized. There are dozens of classes provided with S and defining
new ones is very much part of the programming style. The behavior of classes
can be customized by defining *methods* for S functions when they encounter
arguments from particular classes." [Programming with Data, p. 12]

> "All the computations you do in S, from interactive analysis and visualization
to the full extent of programming, use and create objects." [Programming with Data, 
p. 12]

> "An object's class defines the object in several ways. First, it can define
the *method* used by a function when the object appears as an assignment. 
Whether we are plotting the object, using it in arithmetic, or 
extracting data from it, the computation can be tailored to the particular
object by a method defined for that class. Second, the *representation* of 
the object is defined by that class. A method using the class can count on 
finding certain information in the object, because the class representation 
is defined and accessible. The simplest classes contain *atomic* data---numbers
of various kinds, logical (T or F) values, or character strings. ... New classes
are built up from existing ones, most often by including several *slots* in 
the representation, each slot containing some simpler class that defines part
of the information in the new class. Slots have names, and programmers can 
extract or replace information by referring to the slots, using the operator
`@`. ... The third major contribution of classes comes from relations between 
classes. When one class includes all the behavior of another we say it 
*extends* the other class. Class extension helps greatly in defining new 
classes: all the methods defined for the earlier class are taken over by the
new class, with no reprogramming." [Programming with Data, p. 13] 

> "One kind of extension is especially basic to the language. A *virtual* class
exists so other classes can extend it; it groups together classes that share
some important behavior. All the atomic classes 
mentioned above [numeric, logic, character] share 
the essential notion of having some data values, their elements, which 
can be extracted and replaced by referring to their *index*, their
position in the object. S calls these objects *vectors*, and the virtual
class `vector` exists so all vector classes can extend it."
[Programming with Data, p. 13]

> "An S database contains all S objects, each associated with a name. The
objects can be anything at all: datasets, functions, whatever information 
we need to keep and reuse (everything is an object, remember?)." 
[Programming with Data, p. 14]

> "When you refer to an object by name, whether it's a function or an object
containing data, S *searches* for the object in the databases currently
attached. ... The first name on the list is always the working database. ...
The rule is that S always looks in order in the databases in the search list."
[Programming with Data, p. 15]

> "If other databases have objects we need (either functions or data), we can 
add these to the search list by calling `library` or `attach`." [Programming 
with Data, p. 16]

> "However, it comes about, defining a new method is the workhorse of 
programming with objects in S. Conversely, defining a new class is less common. 
Classes encapsulate how we think about the objects we deal with, what 
information the objects contain, and what makes them valid. You will likely
write many more methods than class definitions, particularly since each new
class definition typically generates a number of new methods. But the usefulness
of your project will depend on good design of the object classes, probably 
more than anything." [Programming with Data, p. 33]

> "Matrices are examples of S *structures*: objects that take a vector and
add some structure to it." [Programming with Data, p. 35]

> "It's also possible to convert objects into the new class by a call to
`as`." [Programming with Data, p. 39]

> "S provides a class definition mechanism for such situations. We can 
decide what information the class needs, and then define methods for 
functions to make the class objects behave as users would expect. Users
of the methods can for most purposes forget how the data is implemented and
just work with the concept of the data." [Programming with Data, p. 38]

> "Classes can be defined in terms of named *slots* containing the 
relevant information." [Programming with Data, p. 38]

> "For programming with data, certainly when using S, the single most 
central aspect concerns organizing data into objects, specifically by 
designing classes. The challenge includes making the class correspond
cleanly to the key concepts about the data, providing enough methods
to let users work easily with the data, while keeping users from 
misleading results or unnecessary problems." [Programming with Data,
p. 44]

> "Modeling makes use of the *formula* class [i.e., with the ~] to 
provide a symbolic definition of the model."  [Programming with Data, 
p. 59]

> "Every evaluation in S, and every step of every evaluation, produces
an object as its result." [Programming with Data, p. 65]

> "Mathematical functions and transformations operate on a numeric 
object to produce another numeric object of the same size and 
'structure'. Structures in S are classes of objects that add to 
ordinary vectors some notion of the values being organized in 
space or time. Matrices, general multiway arrays, and time series
are the most commonly used structures." [Programming with Data, p. 143]

> "Vectors are S objects containing *n* 'elements' that can be indexed 
numerically." [Programming with Data, p. 196]

> "The virtual class `vector` glues all the specific vector classes 
together. A vector class id *defined* to be one that extends `vector`."
[Programming with Data, p. 196]

> [The vector classes alread defined in S] include most of the lowest-level
building blocks for organizing data. The most basic of S vectors contain
numbers, logical values, character strings, raw bytes, or other S 
objects as their elements. All but the last of these are what we 
call *atomic* vectors in S. Atomic vectors are defined by the fact 
that a single element from such a vector is a vector of the same 
class as the whole vector. Vectors that contain other S objects as
elements, rather than atomic data, are called *recursive*, in the
sense that the elements of the vector can be any S class."
[Programming with Data, p. 197]

> "Of the atomic vectors, those containing numbers dominate the population 
of S objects in the world, and the class 'numeric' dominates those. 
Technically, it corresponds to double-precision floating-point data. 
For S users, that technicality usually doesn't matter; only when you 
need to understand issues of accuracy or when you communicate with 
subroutines in, say, C or Fortran does it affect your programming.
There are other classes of numbers as well: 'integer' for integers, 
'single' for single-precision floating-point, and 'complex' for 
numbers in the complex plane." [Programming with Data, p. 197]

> "Logical values in S are TRUE and FALSE, as you would expect. The 
internal data type of these is the same as for class 'integer', for 
historical reasons and for consistent mapping to C and Fortran. Again,
you don't care in most cases." [Programming with Data, p. 197]

> "Character strings in S are represented as ordinary characters 
bounded by single or double quote characters. The class 'string' 
represents a vector of such character strings, plus some optional 
additional information to deal with uses of strings in matching or
to provide computations using the 'levels', the unique character
strings meaningful for this object. Class 'string' differs from others
in this section in that it is built up from basic classes in terms
of slots, rather than being directly defined by its correspondence to
a data type in C." [Programming with Data, p. 197]

> "Lists are the fundamental recursive class: a simple vector whose
elements are arbitrary objects." [Programming with Data, p. 198]

> "Most vector classes supplied with S support the notion of missing
data or 'NA'. The best way to think of this is as a state that can 
be tested for each element of the vector, by calling the function
`is.na`. [This] returns an object like `x` [the input to `is.na` in 
the example], with TRUE wherever the corresponding element of `x` is
missing." [Programming with Data, p. 199]

> "S differs fundamentally from languages like C or Java, where 
individual values, pointers, or references are the basic ingredients
in representing data. In S, whole objects are the elementary ingredients,
and the natural approach to representing more complex data reflects 
this." [Programming with Data, p. 208]

> "The ability of S objects to contain other S objects allows us to 
represent data or arbitrary complexity." [Programming with Data, p. 208]

## Connections

> "Most interesting programming will deal with data that originated in some
'outside' application or process. The application will have left some data
around somewhere, say on a file. We need to make a connection from the file to
S in order to read the data in and work with it. S provides an unlimited 
variety of ways to do this, both through existing functions and through 
tools that let you design your own functions." [Programming with Data, p. 16]

> "Providing the character string name of a file is only a special case. Any 
S connection object would do instead. Connection objects represent all the kinds
of things in your computing environment from which S can read data, or to which
S can write data. The connection objects can be manipulated in a variety of 
ways in S, when you want more control over how data is transferred. The most 
important way to manipulate a connection is to open it. We didn't open [the file
in an earlier example of using `scan`], so `scan` opened it for us, and then 
closed it again before returning. Another call to `scan` with the same file
would start reading again at the beginning of the file. Fine for this example, 
but in some cases we might want to read pieces of the data from the file, look
at those, and then decide what to read next. ... The essential trick to scanning
sequentially is to open the file first. Then each successive call to `scan` will 
leave the connection open and pick up reading where the last call left off. ...
As a final step, we explicitly closed the connection. This isn't required but
it is good housekeeping, freeing up operating system resources and preventing
any accidental use of the connection later on." [Programming with Data, 
pp. 18--19]

> "Connection objects unify the *connections* between S and the rest of the
computing environment, so far as input and output is concerned. A connection
object represents something to which streams of bytes will be written or 
from which streams of bytes will be read." [R Programming for Research, p. 373]

> "The most common example of connections is a file in the file system, 
given as a character string [in the `readLines` function]. The character string
is interpreted as a reference to a file, the S evaluation manager opens this
as an S file connection, and `readLines` reads from this connection."
[Programming with Data, pp. 373--374]

> "Files are a particular class of connection; in the terminology of S classes, 
the class 'file' extends the virtual class 'connection'. Other connection
classes connect S to special kinds of files, to other processes via pipes, or to
S character vectors directly. Objects of other connection classes are 
supplied as arguments to functions operating on connections the same way
files are, but are created using a function that specifies the class of 
connection object." [Programming with Data, p. 374] 

> "Files and fifos correspond to paths; that is, to a character string made
up of directories, subdirectories, and a final file name. The names are 
separated by the character '/': if the first character is not a '/' the 
path is assumed to start in the local directory, where the S session was
invoked. These are similar to the rules that the command shell and other
interfaces to the operating system apply. The path must be a legal file
path in the same sense as it would for use by the shell. By default, S will
create the file if it does not exist. If the file does exist, S will not
truncate the file but will begin reading at the start of the file and 
writing at the end." [Programming with Data, p. 378]

## Parser

> "The S parser keeps prompting for more input until is has a syntactically 
complete expression." [Programming with Data, p. 20]

> "When you communicate a task to S, you usually type some text. The text is
parsed; once that happens (and assuming S can make syntactic sense of what you
typed), an S object is created corresponding to the text. Normally, S then 
goes on to *evaluate* that object." [Programming with Data, p. 70]

## S / R

> "The S language has a syntax that looks much like other 'scientific' 
languages, especially the C family of languages (such as C, C++, Java, 
or awk). It has some uncommon features (e.g., very general kinds of 
assignments) and avoids some common ones (e.g., declarations). The 
differences of form are not very important ... more important, however, 
are differences in how you use the language. You never write a program
in S. Rather than users having the task of creating a program, users
start an S session and give *it* tasks. So, S is a programming 
environment without programs. In place of programs, you use, create, 
and modify S *objects*. *Everything is an object.* S computes with 
objects and manages them for the user. This includes maintaining
databases of objects. Objects hold data about the world outside, but
they also are used to define everything in S itself." [Programming with Data, 
p. 62]

> "S objects are much more general than those of other languages [like C 
and Java], and farther from the hardware. Where single numbers and bytes 
provide the atoms for languages like C or Java, the atomic objects in 
R are dynamic, self-describing vectors of arbitrarily many numbers, 
characters, strings, or raw bytes. Similarly, where the most elementary
computations in other languages are modeled on machine instructions
(conceptually at least), it's best to think of the elementary S
computation as a call to some subprogram (say, a C subroutine) that 
computes some well-defined result without coming back to S for further 
information. ... This 'atomic-ness' of the computations comes because S 
turns control over to the routine; until the routine exits, the S 
evaluator and object management exert no influence." 
[Programming with Data, p. 62]

> "In terms of objects and computations, then, S is a higher level 
language than, say, C. This makes many experienced programmers 
nervous---are they less in control? Yes, in a sense, and deliberately
so. Remember our main goal: to turn ideas into software, quickly and
faithfully. S takes over much of the low-level organization, so that
each conceptual step the program takes can do more, and get us closer
to the results we need. Occasionally, the computational overhead
of this approach slows down the mechanics of the computing importantly.
This is a serious point. There are good ways to deal with the problems
... But the best advice is this: don't worry about such issues until 
you *really* need to." [Programming with Data, p. 62]

> "Everything that goes on in S can be thought of in terms of tasks
and objects. Tasks are the computations and objects are the
things that the computations manipulate. Tasks and objects each 
rely especially on one organizing principle. For tasks, this is
*functions*: each step in S takes in carrying out a task is likely 
to involve evaluating a call to a function. ... As tasks are 
organized by functions, objects are organized by *classes*. 
Each S; object has a class that describes what the object is, 
what information it contains, and how it relates to other
classes. In most cases ... you don't need to know the class of
objects: just assume the class is chosen to be natural for the
object: 'numeric' for numerical results, 'logical' for the 
results of tests, and so on. The class helps the object to 
be interpreted correctly when used in later tasks. ... Functions
and classes come together in *methods*. These describe how function
calls should be evaluated, based on the classes of objects 
appearing as arguments. A function with different methods is 
a *generic* function: the actual definition to be used for the
function is selected by S for each call." 
[Programming with Data, p. 63]

> "To get things going, you start a *session* with S. You then 
communicate with S by giving it a task. S tries to perform the 
task and then waits for the next task. The session continues
through successive tasks until you decide to quit. Performing a 
task means evaluating some S expression, in several steps; 
typically, each step is a call to some S function. So the 
communication with S has three layers: the session, the task
within the session, and the evaluations within each task. The
mechanics of starting and quitting the session, and of sending
individual tasks to it, vary depending on the particular user
interface you are using. ... A common interface is one in which 
the user is prompted to type an S expression. When the expression
is complete and the user tells S to go ahead (by the `Enter` key, 
say), S takes this as a task. Specifically, S parses the typed
text, evaluates the resulting expression, and perhaps somes 
the result to the user. Once this task is done, S goes back to 
waiting for the next task." [Programming with Data, pp. 64--65]

> "It's worth re-emphasizing something that is missing from these
concepts: a *program*. S is a programming language and 
programming environment, but unlike more traditional environments, 
the user is not asked to write a 'complete program' that has to 
'run' to produce results. The communication with S reverses 
much of the traditional emphasis: instead of users having the 
task of creating and running programs, users give S tasks that
S carries out. This style of communication is more typical of
word processors and other interactive software than of programming
languages. All the same, S is a real programming language, but 
without the concept of a user-written 'program'." [Programming 
with Data, p. 65]

> "The S programming language will be familiar in appearance to 
anyone used to programming in C or other languages that share a 
similar style. It shares the control structures, assignment
expressions, function call and operator syntax of this family of
languages (roughly, 'scientific' style programming). To that are
added some extensions to function calling, some additional 
operators, and a much more general form of assignment expressions.
The most important difference, however, is not syntax. The 
fundamental S concepts of task and evaluation cause the *effect* of
the expression to be very different from that in other languages.
Also, the ability to deal with the language itself as an S object
provides new ways to program." [Programming with Data, p. 128]

> "An S expression is *complete* when it satisfies the syntax of
an expression as described ... in the online documentation 
`?Syntax`." [Programming with Data, p. 128]

> "Several complete S expressions can be combined into one, by 
enclosing them in braces, and separating them by newlines or 
semicolons. ... With the braces, the whole thing is treated as 
a single expression." [Programming with Data, p. 130]   

> "The function 'library' is a specialized version of 'attach' 
designed for attaching S system libraries, but not restricted 
to that use. ... The S function 'library' works very much like
'attach', but is designed particularly to attach libraries defined
in your version of S. This mainly amounts to 'library' recognizing 
some short forms for such libraries; for example, 'library(java)' is
a short form for the subdirectory 'java' under the S library directory.
... The 'library' function also differs from 'attach' in that it
attaches databases read-only and has slightly different rules for 
the position in which the attached database appears." 
[Programming with Data, pp. 223--225]

## Regular expressions

> "*Regular expression matching* interprets the strings in [a table] in 
terms of special character patterns familiar from some text editors, 
such as vi or emacs, and from programming tools such as grep, awk, or
perl. Regular expressions are a 'little language' to describe classes
of characters, positions in strings, and various other string patterns.
... Regular expressions interpret certain characters as special in 
determining whether the regular expression string matches a target
string: `^ $ [ ] . \ ( ) - +`. ... Characters other than the special 
characters match themselves. A special character is made non-special 
by preceding it by '\'." [Programming with Data, p. 152]

> "Regular expressions will win no prizes for an elegant language. 
Programming complicated patterns with them is tricky and produces 
extremely obscure code. Still, regular expressions are widely used
and quite well defined, at least in the sense that there is a 
standard definition, as part of the *Posix* standard for operating
system interfaces. (S uses this standard definition of regular 
expressions.) Provided you keep to simple use of them, regular 
expressions can be a substantial help in manipulating strings." 
[Programming with Data, p. 153]

> "**glob** *v.,n.* To expand special characters in a wildcarded
name, or the act of doing so (the action is also called 
*globbing*). The Unix conventions for filename wildcarding have
become sufficiently pervasive that many hackers use some of them
in written English, especially in email or news on technical 
topics. Those commonly encountered include the following: 
[asterisk]: wildcard for any string ...; ?: wildcard for any 
single character ...; []: delimites a wildcard matching any of the 
enclosed characters; {}: alternation of comma-separated values; thus,
'foo{baz,qux]' would be read as 'foobaz' or 'fooqux'. ...
Note that glob patterns are similar, but not identical, to those used
in regexps." [Hackers New Dictionary, p. 218]

> "**grep** *vi.* [from the qed/ed editor idiom g/re/p, where 're'
stands for a regular expression, to Globally search for the 
Regular Expression and Print the lines containing matches to it, 
via Unix grep(1)] To rapidly scan a file or set of files looking 
for a particular string or pattern ... By extension, to look for 
something by pattern." [New Hackers Dictionary, p. 226]

> "**regexp** *n.* [Unix] 1. Common written and spoken abbreviation
for 'regular expression', one of the wildcard patterns used, e.g., 
by Unix utilities such as grep(1), sed(1), and awk(1). These use 
conventions similar to but more elaborate than those described 
under 'glob'. For purposes of this lexicon, it is sufficient to 
note that regexps also allow complemented character strings using
'^'; thus, one can specify 'any non-alphabetic character' with 
[^A-Za-z]." [New Hackers Dictionary, p. 382]

## Graphics

> "Rather than a single graphics library or system, S actually comes 
with several and with the potential for adding others." [Programming 
with Data, p. 161]

> "The range of graphics software in modern computing is tremendous, 
and the potential for *interfaces* to S software equally striking."
[Programming with Data, p. 161]

> "[SVG graphics are] a way of drawing pictures in the browser by 
specifying individual shapes---a circle of this size in the corner; 
a rectangle of that size below it---which can be animated with code: 
'It's drawing with math'." [Coders, pp. 101--102]

## git / GitHub

> "They were aggressive about tweaking and changing Facebook, 
regularly 'pushing' new code out to users that would create
features like Facebook's famous 'Poke', or a 'Notes' app that
let people write longer posts. They were daredevils; sometimes a 
new feature would have been written so eagerly and hastily that it
produced unexpected side effects, which they wouldn't discover until, 
whoops, the code was live on the site. So they'd push the code out
at midnight and then hold their breath to see whether it crashed 
Facebook or not. If everything worked, they'd leave; if it caused
a catastrophe, they'd frantically try to fix it, often toiling until
the early morning, or sometimes just 'reverting' it back to the old
code when they simply couldn't get the new feature working." 
[Coders, p. 3]

> "[Enhancing careers is] also why so many release their weekend
just-for-fun side-projects as open source code on sites like
GitHub. There's the pleasure of letting others see your work, the
joy of discovering that some weird tool you crafted for yourself
is also useful for others; plus, you can learn a lot from looking
at other people's open code and seeing how they built things."
[Coders, p. 163]

> "**handle** *n.* 1. [from CB slang] An electronic pseudonym; a
'nom de guerre' intended to conceal the user's true identity."
[New Hackers Dictionary, p. 239]

> "**README file** *n.* Hacker's eye-introduction traditionally 
included in the top-level directory of a Unix source distribution, 
containing a pointer to more detailed documentation, credits, 
miscellaneous revision history, notes, etc. (The file may be named
README, or READ.ME, or rarely ReadMe or readme.txt or some other 
variant.) ... When asked, hackers invariably relate the README
convention to the famous scene in Lewis Carroll's *Alice's 
Adventures in Wonderland* in which Alice confronts magic 
munchies labeled 'Eat Me' and 'Drink Me'." [New Hackers 
Dictionary, pp. 378--379]

## Other languages

> "I'll posit that BASIC is, historically, the most consequential 
computer language in history because it dramatically threw open the
floodgates to amateurs. Back when Wilkes was hacking away, the 
Assembly language was pretty cryptic to read and write. It's what's known
as a lower-level language, which takes a lot of work to learn to read
and master. By the time the MIT hackers arrived, higher-level languages
that looked a lot more like Standard English were commonly in use, such
as Fortran, aimed at helping everyday scientists and mathematicians
use computers to do calculations, or COBOL, designed for businesses.
But BASIC was one of the easiest yet. Invented in 1964 at Dartmouth 
College, it stood for a Beginner's All-purpose Symbolic Instruction 
Code, and used fairly simple commands that a newbie could readily 
grasp and wield." [Coders, p. 40]

## Testing / Bugs 
> "The general approach suggested in this section is to organize the
tests as S expressions, specifically called *assertions*. We define
an assertion to be an S expression that is expected to evaluate to
TRUE. As your software evolves, you can build up a collection of 
assertions; testing them after making changes to your [R project]
will help catch problems and provide some confidence in the software."
[Programming with Data, p. 197]

> "Admiral Grace Hopper (an early computing pioneer better known for 
inventing COBOL) liked to tell a story in whcih a technician solved
a glitch in the Harvard Mark II machine by pulling an actual insect
out from between the contacts of one of its relays, and she 
subsequently promulgated 'bug' in its hackish sense as a joke
about the incident (though, as she was careful to admit, she was not
there when it happened). For many years the logbook associated
with the incident and the actual bug in question (a moth) sat in a 
display case at the Naval Surface Warfare Center." [New Hackers 
Dictionary, p. 94]

## R Projects

In S, you already had "chapters", which seem like they were a similar 
idea. [Programming with Data]

## TeX

> "**TeX** *n.* ... An extremely powerful macro-based text formatter 
written by Donald E. Knuth, very popular in the computer-science
community ... . TeX fans insist on the correct (and gutteral) 
pronunciation, and the correct spelling (all caps, squished together,
with the E depressed below the baseline; the mixed-case 'TeX' is 
considered an acceptable kluge on ASCII-only devices). ... Knuth 
began TeX because he had become annoyed at the declining quality of 
the typesetting in volumes I--III of his monumental *Art of Computer
Programming*. ... In a manifestation of the typical hackish urge
to solve the problem at hand once and for all, he began to design 
his own typesetting language. He thought he would finish it on 
his sabbatical in 1978; he was wrong by only about 8 years. The language
was finally frozen around 1985, but volume IV of *The Art of Computer
Programming* is not expected until 2002. The impact and influence of
TeX's design has been such that nobody minds very much. Many great
hackish projects have started as a bit of toolsmithing on the way
to something else; Knuth's diversion was simply on a grander scale than
most. TeX has also been a noteworth example of free, shared, but 
high-quality software. Knuth used to offer monetary awards to people
who found and reported bugs in it; as the years wore on and the few
remaining bugs were fixed (and new ones even harder to find(, the bribe
went up." [New Hackers Dictionary, p. 442]

> "**WYSIWYG** *adj.* Describes a user interface under which 'What You
See Is What You Get", as opposed to one that uses more-or-less
obscure commands that do not result in immediate visual feedback."
[New Hackers Dictionary, p. 494]

## Open-source software

> "This relationship to property gave birth to a radical idea: 'free / 
libre' software. That revolution happened when MIT officials, in the 
early 80s, realized that over the years the student hackers had
written a ton of incredibly valuable software for the MIT computers. 
So the officials decided to make some money off it. One for-profit
computer firm called Symbolics asked MIT if it could license all that
cool software to run on *its* computers. Sure, said MIT. So Symbolics
duly licensed the code, and the Symbolics employees began tweaking
and changing and adding new features to it. But whenever Symbolics 
created a new feature, it kept it proprietary. It wasn't sharing 
those innovations openly so the next generation of programmers
could learn from it. That annoyed [Richard] Stallman. He eventually 
left MIT and invented an entirely different licensing paradigm, 
called the General Public License. It works like this: Let's say 
I wrote an email program and issued it under the General Public 
License, because I'm a public-minded hacker who likes to share
my work freely. Cool: If you download the email program, the GPL
means you're also allowed to look at my source code; to modify 
the email software; and to distribute your remix of my work. But
there's one extra element here: If you modify the code and start 
distributing your new version, you have to issue all *your* 
modifications under the GPL too. You can't keep that new code secret. 
You're not prevented from making money off your work; you can sell
the code as a commercial product. (It's 'free' as in 'free speech', 
not 'free' as in 'free beer', as Stallman pointed out.) But you have
to publicly release your modified version of the source code, so that
other people can examine it, remix it, and share it, too---a process
that carries on, ad infinitum, forever, for anyone who uses my / your
code. ... It was a gauntlet thrown down in the name of openness, 
transparency, and control. Its message: You should never trust 
software if the person making it won't show you the code."
[Coders, pp. 237--238]
