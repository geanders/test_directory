
## What is programming?

John Chambers defines programming as "a language and environment to 
turn ideas into new tools." [Programming with Data, p. 2]

> "This book is about *programming with data*, meaning that we want to
extend the tools available in some way, to *program* the system to 
implement some ideas we have." [Programming with Data, p. 2]

> "Sometimes, it seems that the software we use just sort of sprang
into existance, like grass growing on the lawn. But it didn't. It was
created by someone who wrote out---in code---a long, painstaking set of
instructions telling the computer precisely what to do, step-by-step, 
to get a job done. There's a sort of priestly class mystery cultivated
around the word *algorithm*, but all they consist of are instructions:
Do this, then do this, then do this. News Feed [in Facebook] is now an
extraordinarily *complicated* algorithm involving some trained machine
learning; but it's ultimately still just a list of rules." [Coders, p. 10]

> "The first recorded use of 'Hello, World!' was in 1972, when a young 
computer scientist named Brain Kernighan was writing the manual explaining
how to program in the coding language called B. He wanted to show the simplest
thing you could get B to do, which was to print out a message. As he told 
me, he'd seen a cartoon of a chick coming out of an egg, saying 'Hello, World!',
and liked its funny, quirky ring. So he wrote a simple snippet of B code 
that displayed that little message. Coders quickly glommed on to Kernighan's
witty idea, and ever since then, virtually every guide to a programming
language---and there are over 250---begins with that one incantation. 
'Hello, World!' neatly distilled the existential jolt of coding: the 
creation of a life-form that jolts into being." [Coders, p. 14]

> "More than introversion or logic, though, coding selects for people who
can handle endless frustration. Because while computers may do 
whatever you tell them, you need to give them inhumanly precise 
instructions. ... Programming languages are languages, a method of 
speaking to machines; but to speak to a computer is to speak to the 
most literal-minded entity on the planet, a ruthlessly prissy 
grammarian. When we speak to humans, they put a lot of work into 
helping interpret what we say. Computers don't. They will take every
single last one of your smallest errors and grind them in your face, 
until you fix them." [Coders, p. 17] 

> "'When you learn to program a computer, you almost never get it
right the first time,' noted the pioneering computer scientist and
educator Seymour Papert, back in 1980. He regarded the experience as
the pivot around which all coder psychology turns. You write some code, 
you try to run it; it fails; so most of your job is figuring out what the
hell you just did wrong. Those who can handle that daily vexation thrive.
Those who can't, flee." [Coders, pp. 17--18] 

> "Code, in other words, is really good at making things *scale*. Computers
may require utterly precise instructions, but if you get the instructions
right, the machine will tirelessly do what you command over and over and
over again, for users around the world. ... Solve a problem once, and you've
solved it for everyone." [Coders, p. 20]

> "Since they have, at their beck and call, machines that can repeat
instructions with robotic perfection, coders take a dim view of doing 
things repetitively themselves. They have a dislike of inefficiency
that is almost aesthetic---they recoil from it as if from a disgusting
smell. Any opportunity they have to automate a process, to do something
more efficiently, they will." [Coders, p. 20]

> "[Wesley Clark] wanted to make the world's first 'personal computer', 
one that could fit in a single office or laboratory room. No more 
waiting in line; one scientist would have it all to himself (or, more
rarely, herself). Clark wanted specifically to target biologists, since
he knew they often needed to crunch data in the middle of an experiment.
At that time, if they were using a huge IBM machine, they'd need to stop
and wait their turn. If they had a personal computer in their own lab? They
could do calculations on the fly, rejiggering their experiment as they 
went. It would even have its own keyboard and screen, so you could program
more quickly: no clumsy punch cards or printouts. It would be a symbiosis of
human and machine intelligence. Or, as Wilkes put it, you'd have 
'conversational access' to the LINC: You type some code, you see the result
quickly. Clark knew he and his team could design the hardware. But he needed
Wilkes to help create the computers' operating system that would let the user
control the hardware in real time. And it would have to be simple enough that
biologists could pick it up with a day or two of training." [Coders, p. 32]

> "When they had a rough first prototype [of the LINC] working, Clark tested
it on a real-life problem of biological research. He and his colleague 
Charles Molnar dragged a LINC out to the lab of neurologist Arnold Starr, who
had been trying and failing to record the neuroelectric signals cats produce
in their brains when they heard a sound. Starr had put an electrode implant
into a cat's cortex, but he couldn't distinguish the precise neuroelectirc
signal he was looking for. In a few hours, Molnar wrote a program for the 
LINC that would play a clicking noise out of a speaker, record precisely 
when the electrode fired, and map on the LINC's screen the average response
of the cat to noises. It worked: As data scrolled across the screen, the
scientists 'danced a jig right around the equipment'." [Coders, p. 33]

> "'The distance between looking like a genius and looking like an 
idiot in programming? It's *one character wide.*'" [Rob Spectre, on 
missing a colon, Coders, p. 64]

> "Coding is, in a profound way, less about making thinks than about 
fixing them. The pioneering computer scientist Seymour Papert had a 
koan: *No program works right the first time.*" [Coders, p. 66]

> "Programmers are obsessed with efficiency. ... Removing the friction 
from a system is an aesthetic joy; [programmers'] eyes blaze when they
talk about making something run faster, or how they eliminated some 
bothersome human effort from a process." [Coders, p. 122]

> "Computers, in many ways, inspire dreams of efficiency greater than
any tool that came before. That's because they're remarkably good at
automating repetitive tasks. Write a script once, set it running, and
the computer will tirelessly execute it until it dies or the power
runs out. What's more, computers are strong in precisely the ways that
humans are weak. Give us a repetitive task, and our mind tends to 
wander, so we gradually perform it more and more irregularly. Ask us
to do something at a precise time or interval, and we space out and 
forget to do it. ... In contrast, computers are clock driven and superb
at doing the same thing at the same time, day in and day out."
[Coders, p. 124]

> "Larry Wall, the famous coder and linguist who created the Perl 
programming language, deeply intuited this coderly aversion to 
repetition. In his book on Perl, he and coauthors wrote that one of the
key virtues of a programmer is 'laziness'. It's not that you're too lazy
for coding. It's that you're too lazy to do routine things, so it 
inspires you to automate them." [Coders p. 126]

> "'Refactoring' is, in a way, like editing. When you're writing a letter
or a speech or an article, often the first draft is a bit baggy and fuzzy.
You're getting the ideas out onto the page, but they're not crisply stated.
So you repeat yourself; you beat around the bush; your thinking is fuzzy.
But that's okay, because your goal isn't to be perfect, it's to get those 
first words onto the page, so you can reshape and hone them later. 
Editing sharpens and hones those flabby ideas and language. It 
pares down your pointless and windy riffs, so that the prose tightens 
and tempers. That's why editing a piece of writing---lingering over it, 
molding it---can make it shorter, not longer. ... So it is with programming.
Generally speaking, the tighter the code, the better. That's partly because
the fewer lines of code that exist, the less likely one is to introduce
a bug. A huge pile of 'spaghetti code' is a bog in which bugs can hide. 
When the code is shorter and tighter, it's easier to see precisely what
it's supposed to be doing and not doing. It's a forest of spare birch 
trees; you can see right through it." [Coders, p. 136]

> "[The ENIAC Girls] invented groundbreaking ideas in coding. Synder 
realized that if you wanted to debug a program that wasn't running
correctly, it's help to have a 'break point', a moment when you could
stop a program midway through its run. When she pitched the idea to male
engineers running ENIAC, they agreed to implement it; and to this day, coders
use break points as a key part of debugging." [Coders, pp. 190--191]

## Functions

> "S is a *functional* language. S expressions contain function calls. ...
An S function call returns an S object, the value of the call. Usually that's 
all it does: function calls are evaluated to get the value." 
[Programming with Data, p. 7]

> "Calls to functions can have any number of arguments, and the arguments
can be any S expression." [Programming with Data, p. 8]

> "Each function is defined with some set of *formal arguments*. The 
arguments supplied in the call are matched to those in the definition." 
[Programming with Data, p. 9]

> "Not all the arguments in the definition need to be supplied in the call. 
The function can detect missing arguments. There may be a default 
expression included in the definition, or the function may do something
else, or it may be that for this particular call the argument wasn't needed
anyway." [Programming with Data, p. 9]

> "S will complete argument names, so long as you give enough of the 
name to make it unique." [Programming with Data, p. 9]  

> "S has the usual operators for arithmetic, comparisons, and logical 
operations (plus some other operators special to S). ... Operators look
different from other functions because they appear in expressions in 
infix (scientific) notation. When we come to program with such operators, 
though, we will treat them just like ordinary functions, which is what they
are. We put the operator '<' between two arguments instead of in front of
its arguments, but this is just because the interface we are using expects
to parse such expressions. Most users prefer to see arithmetic expressions 
written this way, but in fact the S expression `"<"(amount, 0)` evaluates
exactly the same as `amount < 0`." [Programming with Data, p. 10] 

Check out `?Arithmetic` and `?Logic`.

> "S has a few other operators not found in most languages. The operator
`:` creates a sequence in steps of +/- 1 from its left operand to its right
operand. ... Operator `%%` computes modulus. Some special matrix operators
do computations in numerical linear algebra, such as matrix multiplication.
Additional operators in S extract pieces of objects. Square brackets can 
be used to extract the portion of the object before the `[` that corresponds
to the expression between the square brackets. ... Square brackets can be
extended to apply to matrices, multiway arrays, and other similar objects. ...
Other operators extract single elements, components of lists, or the slots of
an object [e.g., `[[`, `$`, and `@`]." [Programming with Data, p. 11]

> "*Assignment*, written `=` in our examples, is another important S operator. 
S uses assignment in a very general way, both to assign an object corresponding
to a name and also to modify an object in an open-ended variety of ways."
[Programming with Data, p. 11]

> "Assignment operators are used to modify existing objects, when the expression
on the left of the assignment is a function call instead of a name. We call
these expressions *replacements*." [Programming with Data, p. 11]

> "Programming in S begins for real when you start writing S functions."
[Programming with Data, p. 19]

> "Often, you find yourself writing the same, or similar, expressions
over and over. It makes sens to package these as a function." 
[Programming with Data, p. 19]

> "You can create a function by just typing in an expression that defines
and assigns a `function` object. The idea is simple: take an expression
you would use to compute something interesting, precede the expression 
by `function` followed by the parenthesized names of the objects involved,
and that expression defines a function. ... Like any assignment expression, 
this tells S to evaluate the expression on the right of the `=` and associate
it with the name on the left. The difference in this case is that the expression
on the right, when parsed, defines a *function object*. The parser converts
the reserved word `function`, followed by a parenthesized list of arguments, 
followed by an S expression into a function object. The expression is called
the *body* of the function object." [Programming with Data, p. 19]

> "There is *no* difference between a function created by a user's program and
one supplied with S." [Programming with Data, p. 20]

> "Often, we need the function body to contain several expressions, including
assignments. The technique is to enclose these expressions in braces and 
separate them by semicolons or new lines. As in many languages, the expressions
in the braced list are evaluated one after another. In S, the key point is that
the value of the whole braced list is the value of the last expression."
[Programming with Data, p. 20]

> "The other key difference between tasks and function definitions is that
ordinary assignments in the body of the function ... now become *local* 
assignments in the evaluation of a call to [the function]. The assignments
and any storage they require go away when the call is completed."
[Programming with Data, p. 20]

> "Methods in S define how a particular function should behave, based on the
class of the arguments to the function." [Programming with Data, p. 32]

> "Once we can create objects from the class conveniently, we want to look
at them. A method for the function `show` will be called when S automatically
displays the result of a computation. The function takes only one argument, 
`object`, the object to be displayed. The display can be either printed
(the usual choice) or plotted. Two other functions, `print` and `plot`, can
also have methods defined for these two cases. These functions have a more 
general form, but the method for a new class is usually called with just
one argument. The function `summary` is expected to produce a short
description, ideally to fit on a single page regardless of the size of the
object." [Programming with Data, p. 40]

> "A function object contains two types of information. The *formal arguments*
tell S how to interpret calls to the function, and the *body* is the 
expression whose value is returned from the call. ... When the S evaluator
has matched the actual arguments to the formal arguments, it evaluates
the body and returns the resulting object as the value of the call." 
[Programming with Data, p. 79]

> "Because users can call S functions with named and unnamed arguments, 
both the position and the name of an argument in the function 
definition is relevant. We say 'formal' arguments when we want to 
distinguish the arguments in the function definition from the 
'actual' arguments in a call to the function. Besides the names of
the formal arguments, the definition can include assignment 
expressions to create *default* values for arguments that are
needed in evaluating the body, but that are not supplied in the call."
[Programming with Data, p. 79]

> "When S is evaluating the body of the function and, for the first time, 
needs the value of the argument `x`, it will look for a matched 
expression; if there is one, that expression is evaluated and assigned
locally as `x`... Notice that an argument is evaluated when S *needs* the
value; this technique is known as *lazy* evaluation and is essential to 
the generality in treating arguments."  [Programming with Data, p. 80]

> "S expressions consist largely of function calls. Functions are called
by following the definition of the function with a parenthesized list
of arguments. The definition is usually entered by typing the name under
which the function is stored in a database." [Programming with Data, p. 128]

> "A few nonstandard infix operators are supplied as well. The most 
important ... is the `?` operator, which invokes online help. It is 
most commonly used as a unary operator, followed by a name or a 
character string. ... You need ... quotes [e.g., `?"+"`] if the
topic you are asking about is not syntactically a name, since the 
S parser will get an error without the quotes." [Programming with 
Data, p. 129]

> "All the extraction operators [e.g., `[`] can also appear on the left
side of an assignment, in which case they are interpreted to mean replacing
the corresponding subset, element, or slot."[Programming with Data, p. 130] 

> "The `return` control expression causes the current function call to 
return, with the argument to the expression evaluated as the value of the
function call. ... A `return` is not needed if the functio body is a 
braced sequence of expressions and the last expression is the value you 
want to return from the function. In functional languages, `return` 
expressions are rather deprecated, in that they usually make it harder
to see the behavior of the function."  [Programming with Data, p. 136]

> "S assignment expressions consist of an assignment operator, with an
expression on the left and another on the right. The expression on the 
right is the *value* of the assignment; the expression on the left is
either a name or a function call." [Programming with Data, p. 137]

> "When an assignment occurs *inside* an argument to a function, the 
operator `<-` must be used to distinguish the intended argument from 
a named argument ... Otherwise, the operators [`=` and `<-`] behave
identically. The arrow form requires a little more typicing and is less
familiar to programmers from other languages, but it expresses the 
asymmetric relation of the left and right side in an assignment, where 
`=` does not." [Programming with Data, p. 137]

> "Assignment expressions also appear whenever you name an argument in 
a function call, though they are called *named arguments* in this case
and are interpreted somewhat differently. The call to any function 
associates each of the actual arguments with the name of one of the 
formal arguments of the function. S lets you omit names or supply just
enough of the name match, but the end result is the same as if all the
arguments had been named." [Programming with Data, pp. 138--139]

> "Assignments can appear in the argument list in the function *definition*
as well, to specify the default expressions for arguments." 
[Programming with Data, p. 139]

> "Modeling in S takes the data and a description of the model, applies
a numerical fitting algorithm, and returns an object representing the 
fitted model. Methods exist to print, summarize, and plot these models. 
... Models are described in two parts: the general kind of model being
used (linear regression, non-linear regression, tree-based models, etc.)
is determined by the choice of fitting function (`lm`, `nsl`, `tree`, etc.). 
The specific formula is a stylized S expression; specifically, a call to the 
special operator `~`, which can be read as 'is fitted to' in formulas. The
left-side operand defines the variable (the data) to be approximated, the
right-side operand the combination of variables to be used for fitting.
... The formula expression itself (the call to `~`) does no fitting, but 
just returns essentially the expression itself, as a 'formula' object. 
It's up to the fitting function to interpret the formula as a fitting 
task. The `lm` function uses the formula to define a linear model that
it then proceeds to fit by least-squares. The left side, or *response*, 
is an expression defining a numeric vector or matrix. The right side
defines one or more predictor variables; by convention, different
predictors are combined by `+`. The variables appearing in the model 
look like ordinary S objects, and they can be just that. More commonly, 
though, they are defined in the context of some particular dataset. In this
case, the user's call to the fitted function supplies a `data` argument.
The fitting function attaches this object temporarily in order to compute
the information needed to do the actual fit. Therefore, components of the
object can appear as variables in the formula." [Programming with Data, 
p. 167] 

> "Most coding is about breaking a big, hard task down into small pieces.
You don't write one big honking program at one go; you write little chunks
of code, small subroutines---functions, modules---that, when chained together,
accomplish the big task. If you were cooking breakfast, you could think of 
each action you do as a function: Cracking the eggs is function `(crackeggs())`,
buttering the toast is another `(buttertoast())`. Chain them all together in
a logical flow, and that's your main program. Generally when you're coding,
you're focusing on creating one function at a time, and after you've written 
it you're supposed to test it to make sure it works. If you spent days 
writing a long program without testing its various components, it would
almost certainly fail when you tried to run it, and it might be very hard
to figure out which part (or parts) of the program was the problem. So you 
go piece by piece, testing as you go. You get a little 'win' every time a 
function passes its test." [Coders, p. 84] 

## Objects

> "When the S evaluator encounters the name of an object, it takes that
as a shorthand request to get the object from the database. And if nothing
else is done with the results, S will show the object to the user, by 
printing or plotting it. So about the simplest useful S expression is 
just the name of an object." [Programming with Data, p. 7]

> "S will evaluate the right side of the assignment expression and save the
result in a database, called in S the *working data*, under the name on the
left side. Then the object [by that name] is available for future tasks, 
whenever we are working with this database." [Programming with Data, p. 11]

> "Data in S comes in the form of *objects*. *Everything is an object:*
this is a fundamental concept in S. In many ways all objects are treated 
equally. Alls objects have a *class*, allowing computations on the objects
to be customized. There are dozens of classes provided with S and defining
new ones is very much part of the programming style. The behavior of classes
can be customized by defining *methods* for S functions when they encounter
arguments from particular classes." [Programming with Data, p. 12]

> "All the computations you do in S, from interactive analysis and visualization
to the full extent of programming, use and create objects." [Programming with Data, 
p. 12]

> "An object's class defines the object in several ways. First, it can define
the *method* used by a function when the object appears as an assignment. 
Whether we are plotting the object, using it in arithmetic, or 
extracting data from it, the computation can be tailored to the particular
object by a method defined for that class. Second, the *representation* of 
the object is defined by that class. A method using the class can count on 
finding certain information in the object, because the class representation 
is defined and accessible. The simplest classes contain *atomic* data---numbers
of various kinds, logical (T or F) values, or character strings. ... New classes
are built up from existing ones, most often by including several *slots* in 
the representation, each slot containing some simpler class that defines part
of the information in the new class. Slots have names, and programmers can 
extract or replace information by referring to the slots, using the operator
`@`. ... The third major contribution of classes comes from relations between 
classes. When one class includes all the behavior of another we say it 
*extends* the other class. Class extension helps greatly in defining new 
classes: all the methods defined for the earlier class are taken over by the
new class, with no reprogramming." [Programming with Data, p. 13] 

> "One kind of extension is especially basic to the language. A *virtual* class
exists so other classes can extend it; it groups together classes that share
some important behavior. All the atomic classes 
mentioned above [numeric, logic, character] share 
the essential notion of having some data values, their elements, which 
can be extracted and replaced by referring to their *index*, their
position in the object. S calls these objects *vectors*, and the virtual
class `vector` exists so all vector classes can extend it."
[Programming with Data, p. 13]

> "An S database contains all S objects, each associated with a name. The
objects can be anything at all: datasets, functions, whatever information 
we need to keep and reuse (everything is an object, remember?)." 
[Programming with Data, p. 14]

> "When you refer to an object by name, whether it's a function or an object
containing data, S *searches* for the object in the databases currently
attached. ... The first name on the list is always the working database. ...
The rule is that S always looks in order in the databases in the search list."
[Programming with Data, p. 15]

> "If other databases have objects we need (either functions or data), we can 
add these to the search list by calling `library` or `attach`." [Programming 
with Data, p. 16]

> "However, it comes about, defining a new method is the workhorse of 
programming with objects in S. Conversely, defining a new class is less common. 
Classes encapsulate how we think about the objects we deal with, what 
information the objects contain, and what makes them valid. You will likely
write many more methods than class definitions, particularly since each new
class definition typically generates a number of new methods. But the usefulness
of your project will depend on good design of the object classes, probably 
more than anything." [Programming with Data, p. 33]

> "Matrices are examples of S *structures*: objects that take a vector and
add some structure to it." [Programming with Data, p. 35]

> "It's also possible to convert objects into the new class by a call to
`as`." [Programming with Data, p. 39]

> "S provides a class definition mechanism for such situations. We can 
decide what information the class needs, and then define methods for 
functions to make the class objects behave as users would expect. Users
of the methods can for most purposes forget how the data is implemented and
just work with the concept of the data." [Programming with Data, p. 38]

> "Classes can be defined in terms of named *slots* containing the 
relevant information." [Programming with Data, p. 38]

> "For programming with data, certainly when using S, the single most 
central aspect concerns organizing data into objects, specifically by 
designing classes. The challenge includes making the class correspond
cleanly to the key concepts about the data, providing enough methods
to let users work easily with the data, while keeping users from 
misleading results or unnecessary problems." [Programming with Data,
p. 44]

> "Modeling makes use of the *formula* class [i.e., with the ~] to 
provide a symbolic definition of the model."  [Programming with Data, 
p. 59]

> "Every evaluation in S, and every step of every evaluation, produces
an object as its result." [Programming with Data, p. 65]

> "Mathematical functions and transformations operate on a numeric 
object to produce another numeric object of the same size and 
'structure'. Structures in S are classes of objects that add to 
ordinary vectors some notion of the values being organized in 
space or time. Matrices, general multiway arrays, and time series
are the most commonly used structures." [Programming with Data, p. 143]

## Connections

> "Most interesting programming will deal with data that originated in some
'outside' application or process. The application will have left some data
around somewhere, say on a file. We need to make a connection from the file to
S in order to read the data in and work with it. S provides an unlimited 
variety of ways to do this, both through existing functions and through 
tools that let you design your own functions." [Programming with Data, p. 16]

> "Providing the character string name of a file is only a special case. Any 
S connection object would do instead. Connection objects represent all the kinds
of things in your computing environment from which S can read data, or to which
S can write data. The connection objects can be manipulated in a variety of 
ways in S, when you want more control over how data is transferred. The most 
important way to manipulate a connection is to open it. We didn't open [the file
in an earlier example of using `scan`], so `scan` opened it for us, and then 
closed it again before returning. Another call to `scan` with the same file
would start reading again at the beginning of the file. Fine for this example, 
but in some cases we might want to read pieces of the data from the file, look
at those, and then decide what to read next. ... The essential trick to scanning
sequentially is to open the file first. Then each successive call to `scan` will 
leave the connection open and pick up reading where the last call left off. ...
As a final step, we explicitly closed the connection. This isn't required but
it is good housekeeping, freeing up operating system resources and preventing
any accidental use of the connection later on." [Programming with Data, 
pp. 18--19]

## Parser

> "The S parser keeps prompting for more input until is has a syntactically 
complete expression." [Programming with Data, p. 20]

> "When you communicate a task to S, you usually type some text. The text is
parsed; once that happens (and assuming S can make syntactic sense of what you
typed), an S object is created corresponding to the text. Normally, S then 
goes on to *evaluate* that object." [Programming with Data, p. 70]

## S / R

> "The S language has a syntax that looks much like other 'scientific' 
languages, especially the C family of languages (such as C, C++, Java, 
or awk). It has some uncommon features (e.g., very general kinds of 
assignments) and avoids some common ones (e.g., declarations). The 
differences of form are not very important ... more important, however, 
are differences in how you use the language. You never write a program
in S. Rather than users having the task of creating a program, users
start an S session and give *it* tasks. So, S is a programming 
environment without programs. In place of programs, you use, create, 
and modify S *objects*. *Everything is an object.* S computes with 
objects and manages them for the user. This includes maintaining
databases of objects. Objects hold data about the world outside, but
they also are used to define everything in S itself." [Programming with Data, 
p. 62]

> "S objects are much more general than those of other languages [like C 
and Java], and farther from the hardware. Where single numbers and bytes 
provide the atoms for languages like C or Java, the atomic objects in 
R are dynamic, self-describing vectors of arbitrarily many numbers, 
characters, strings, or raw bytes. Similarly, where the most elementary
computations in other languages are modeled on machine instructions
(conceptually at least), it's best to think of the elementary S
computation as a call to some subprogram (say, a C subroutine) that 
computes some well-defined result without coming back to S for further 
information. ... This 'atomic-ness' of the computations comes because S 
turns control over to the routine; until the routine exits, the S 
evaluator and object management exert no influence." 
[Programming with Data, p. 62]

> "In terms of objects and computations, then, S is a higher level 
language than, say, C. This makes many experienced programmers 
nervous---are they less in control? Yes, in a sense, and deliberately
so. Remember our main goal: to turn ideas into software, quickly and
faithfully. S takes over much of the low-level organization, so that
each conceptual step the program takes can do more, and get us closer
to the results we need. Occasionally, the computational overhead
of this approach slows down the mechanics of the computing importantly.
This is a serious point. There are good ways to deal with the problems
... But the best advice is this: don't worry about such issues until 
you *really* need to." [Programming with Data, p. 62]

> "Everything that goes on in S can be thought of in terms of tasks
and objects. Tasks are the computations and objects are the
things that the computations manipulate. Tasks and objects each 
rely especially on one organizing principle. For tasks, this is
*functions*: each step in S takes in carrying out a task is likely 
to involve evaluating a call to a function. ... As tasks are 
organized by functions, objects are organized by *classes*. 
Each S; object has a class that describes what the object is, 
what information it contains, and how it relates to other
classes. In most cases ... you don't need to know the class of
objects: just assume the class is chosen to be natural for the
object: 'numeric' for numerical results, 'logical' for the 
results of tests, and so on. The class helps the object to 
be interpreted correctly when used in later tasks. ... Functions
and classes come together in *methods*. These describe how function
calls should be evaluated, based on the classes of objects 
appearing as arguments. A function with different methods is 
a *generic* function: the actual definition to be used for the
function is selected by S for each call." 
[Programming with Data, p. 63]

> "To get things going, you start a *session* with S. You then 
communicate with S by giving it a task. S tries to perform the 
task and then waits for the next task. The session continues
through successive tasks until you decide to quit. Performing a 
task means evaluating some S expression, in several steps; 
typically, each step is a call to some S function. So the 
communication with S has three layers: the session, the task
within the session, and the evaluations within each task. The
mechanics of starting and quitting the session, and of sending
individual tasks to it, vary depending on the particular user
interface you are using. ... A common interface is one in which 
the user is prompted to type an S expression. When the expression
is complete and the user tells S to go ahead (by the `Enter` key, 
say), S takes this as a task. Specifically, S parses the typed
text, evaluates the resulting expression, and perhaps somes 
the result to the user. Once this task is done, S goes back to 
waiting for the next task." [Programming with Data, pp. 64--65]

> "It's worth re-emphasizing something that is missing from these
concepts: a *program*. S is a programming language and 
programming environment, but unlike more traditional environments, 
the user is not asked to write a 'complete program' that has to 
'run' to produce results. The communication with S reverses 
much of the traditional emphasis: instead of users having the 
task of creating and running programs, users give S tasks that
S carries out. This style of communication is more typical of
word processors and other interactive software than of programming
languages. All the same, S is a real programming language, but 
without the concept of a user-written 'program'." [Programming 
with Data, p. 65]

> "The S programming language will be familiar in appearance to 
anyone used to programming in C or other languages that share a 
similar style. It shares the control structures, assignment
expressions, function call and operator syntax of this family of
languages (roughly, 'scientific' style programming). To that are
added some extensions to function calling, some additional 
operators, and a much more general form of assignment expressions.
The most important difference, however, is not syntax. The 
fundamental S concepts of task and evaluation cause the *effect* of
the expression to be very different from that in other languages.
Also, the ability to deal with the language itself as an S object
provides new ways to program." [Programming with Data, p. 128]

> "An S expression is *complete* when it satisfies the syntax of
an expression as described ... in the online documentation 
`?Syntax`." [Programming with Data, p. 128]

> "Several complete S expressions can be combined into one, by 
enclosing them in braces, and separating them by newlines or 
semicolons. ... With the braces, the whole thing is treated as 
a single expression." [Programming with Data, p. 130]   

## Regular expressions

> "*Regular expression matching* interprets the strings in [a table] in 
terms of special character patterns familiar from some text editors, 
such as vi or emacs, and from programming tools such as grep, awk, or
perl. Regular expressions are a 'little language' to describe classes
of characters, positions in strings, and various other string patterns.
... Regular expressions interpret certain characters as special in 
determining whether the regular expression string matches a target
string: `^ $ [ ] . \ ( ) - +`. ... Characters other than the special 
characters match themselves. A special character is made non-special 
by preceding it by '\'." [Programming with Data, p. 152]

> "Regular expressions will win no prizes for an elegant language. 
Programming complicated patterns with them is tricky and produces 
extremely obscure code. Still, regular expressions are widely used
and quite well defined, at least in the sense that there is a 
standard definition, as part of the *Posix* standard for operating
system interfaces. (S uses this standard definition of regular 
expressions.) Provided you keep to simple use of them, regular 
expressions can be a substantial help in manipulating strings." 
[Programming with Data, p. 153]

## Graphics

> "Rather than a single graphics library or system, S actually comes 
with several and with the potential for adding others." [Programming 
with Data, p. 161]

> "The range of graphics software in modern computing is tremendous, 
and the potential for *interfaces* to S software equally striking."
[Programming with Data, p. 161]

> "[SVG graphics are] a way of drawing pictures in the browser by 
specifying individual shapes---a circle of this size in the corner; 
a rectangle of that size below it---which can be animated with code: 
'It's drawing with math'." [Coders, pp. 101--102]

## git / GitHub

> "They were aggressive about tweaking and changing Facebook, 
regularly 'pushing' new code out to users that would create
features like Facebook's famous 'Poke', or a 'Notes' app that
let people write longer posts. They were daredevils; sometimes a 
new feature would have been written so eagerly and hastily that it
produced unexpected side effects, which they wouldn't discover until, 
whoops, the code was live on the site. So they'd push the code out
at midnight and then hold their breath to see whether it crashed 
Facebook or not. If everything worked, they'd leave; if it caused
a catastrophe, they'd frantically try to fix it, often toiling until
the early morning, or sometimes just 'reverting' it back to the old
code when they simply couldn't get the new feature working." 
[Coders, p. 3]

> "[Enhancing careers is] also why so many release their weekend
just-for-fun side-projects as open source code on sites like
GitHub. There's the pleasure of letting others see your work, the
joy of discovering that some weird tool you crafted for yourself
is also useful for others; plus, you can learn a lot from looking
at other people's open code and seeing how they built things."
[Coders, p. 163]

## Other languages

> "I'll posit that BASIC is, historically, the most consequential 
computer language in history because it dramatically threw open the
floodgates to amateurs. Back when Wilkes was hacking away, the 
Assembly language was pretty cryptic to read and write. It's what's known
as a lower-level language, which takes a lot of work to learn to read
and master. By the time the MIT hackers arrived, higher-level languages
that looked a lot more like Standard English were commonly in use, such
as Fortran, aimed at helping everyday scientists and mathematicians
use computers to do calculations, or COBOL, designed for businesses.
But BASIC was one of the easiest yet. Invented in 1964 at Dartmouth 
College, it stood for a Beginner's All-purpose Symbolic Instruction 
Code, and used fairly simple commands that a newbie could readily 
grasp and wield." [Coders, p. 40]
